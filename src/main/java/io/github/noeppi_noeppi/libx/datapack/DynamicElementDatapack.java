package io.github.noeppi_noeppi.libx.datapack;

import com.google.gson.JsonElement;
import com.mojang.serialization.Codec;
import io.github.noeppi_noeppi.libx.codec.CodecHelper;
import io.github.noeppi_noeppi.libx.util.LazyValue;
import net.minecraft.core.RegistryAccess;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.packs.PackResources;
import net.minecraft.server.packs.PackType;
import net.minecraft.server.packs.metadata.MetadataSectionSerializer;
import net.minecraftforge.forgespi.locating.IModFile;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;

/**
 * A datapack that provides some dynamically json files at fixed locations. The jsons are
 * generated by encoding an element using a {@link Codec}. To add your elements, call
 * {@link #addEntry(ResourceLocation, Codec, Supplier)} in the constructor. The elements
 * are lazily initialised, that means the supplier is called only once, when the element is
 * first queried.
 */
public class DynamicElementDatapack implements PackResources {
    
    private final String name;
    private final Supplier<InputStream> packMcmeta;
    
    @Nullable
    private final RegistryAccess registryAccess;
    private final Map<ResourceLocation, DataEntry<?>> entries;
    
    public DynamicElementDatapack(IModFile file, String id, @Nullable RegistryAccess registryAccess) {
        this.name = file.getFileName() + "/" + id;
        this.packMcmeta = DatapackHelper.generatePackMeta(file, "Dynamic element datapack: " + file.getFileName() + "/" + id);
        this.registryAccess = registryAccess;
        this.entries = new HashMap<>();
    }
    
    protected <T> void addEntry(ResourceLocation path, Codec<T> codec, Supplier<T> value) {
        this.entries.put(path, new DataEntry<>(codec, new LazyValue<>(value)));
    }

    @Nonnull
    @Override
    public String getName() {
        return this.name;
    }
    
    @Nullable
    @Override
    public InputStream getRootResource(@Nonnull String fileName) throws IOException {
        return PACK_META.equals(fileName) ? this.packMcmeta.get() : null;
    }

    @Nonnull
    @Override
    public InputStream getResource(@Nonnull PackType type, @Nonnull ResourceLocation location) throws IOException {
        if (type == PackType.CLIENT_RESOURCES) throw new FileNotFoundException(type.getDirectory() + "/" + location);
        if (this.entries.containsKey(location)) {
            return this.entries.get(location).access(this.registryAccess);
        } else {
            throw new FileNotFoundException(type.getDirectory() + "/" + location);
        }
    }

    @Nonnull
    @Override
    public Collection<ResourceLocation> getResources(@Nonnull PackType type, @Nonnull String namespace, @Nonnull String path, int maxDepth, @Nonnull Predicate<String> filter) {
        if (type == PackType.CLIENT_RESOURCES) return List.of();
        return this.entries.keySet().stream()
                .filter(rl -> rl.getNamespace().equals(namespace))
                .filter(rl -> rl.getPath().startsWith(path + "/"))
                .filter(rl -> {
                    String[] parts = rl.getPath().split("/");
                    return parts.length > 0 && parts.length <= maxDepth && filter.test(parts[parts.length - 1]);
                })
                .toList();
    }

    @Override
    public boolean hasResource(@Nonnull PackType type, @Nonnull ResourceLocation location) {
        return type == PackType.SERVER_DATA && this.entries.containsKey(location);
    }

    @Nonnull
    @Override
    public Set<String> getNamespaces(@Nonnull PackType type) {
        return this.entries.keySet().stream().map(ResourceLocation::getNamespace).collect(Collectors.toUnmodifiableSet());
    }

    @Nullable
    @Override
    public <T> T getMetadataSection(@Nonnull MetadataSectionSerializer<T> deserializer) {
        return null;
    }
    
    @Override
    public void close() {
        //
    }

    private record DataEntry<T>(Codec<T> codec, LazyValue<T> value) {
        
        public InputStream access(@Nullable RegistryAccess registryAccess) throws IOException {
            T t = this.value().get();
            JsonElement elem = registryAccess == null ? CodecHelper.JSON.write(this.codec(), t) : CodecHelper.JSON.write(this.codec(), t, registryAccess);
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            Writer writer = new OutputStreamWriter(out, StandardCharsets.UTF_8);
            writer.write(DatapackHelper.GSON.toJson(elem) + "\n");
            writer.close();
            out.close();
            return new ByteArrayInputStream(out.toByteArray());
        }
    }
}
